
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DMRG for electronic structure calculations &#8212; BLOCK 1.5.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinxdoc.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Block program as a standalone solver" href="examples.html" />
    <link rel="prev" title="Block Installation" href="build.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="examples.html" title="Block program as a standalone solver"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="build.html" title="Block Installation"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">BLOCK 1.5.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">DMRG for electronic structure calculations</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="dmrg-for-electronic-structure-calculations">
<span id="dmrg-pyscf"></span><h1>DMRG for electronic structure calculations<a class="headerlink" href="#dmrg-for-electronic-structure-calculations" title="Permalink to this headline">¶</a></h1>
<p>Block program supports two executing modes: running standalone through command
line or as a plugin of other quantum chemistry package.  The Python-based
quantum chemistry program package <a class="reference external" href="http://www.pyscf.org">PySCF</a> provides a
simple solution to run Block program.  It is the recommended way to use
Block program in most scenario.</p>
<p>In PySCF, DMRG program is mainly used as a replacement of Full CI solver for
large active space CASCI or CASSCF problem.  On top of DMRG-CASCI and
DMRG-CASSCF, MPS-PT can be called through Block-PySCF interface.  Using Block
with PySCF,  systems around 50-active-orbital DMRG-CASSCF or 30-active-orbital
MPSPT can be studied in a regular basis.</p>
<div class="section" id="casci-casscf-in-pyscf">
<h2>CASCI/CASSCF in PySCF<a class="headerlink" href="#casci-casscf-in-pyscf" title="Permalink to this headline">¶</a></h2>
<p>PySCF is a collection Python modules for electronic structure simulation
and theory developing.  In this section, we briefly review the usage of
PySCF.  More usage details of PySCF package can be found in PySCF online
documents <a class="reference external" href="http://www.pyscf.org">http://www.pyscf.org</a>.  If you have PySCF installed and setup
correctly (see <a class="reference external" href="http://www.pyscf.org/install.html">http://www.pyscf.org/install.html</a>), you can create a
Python script for CASCI and CASSCF calculation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cat c2_cas.py
from pyscf import gto, scf, mcscf
mol = gto.M(atom=&quot;N 0 0 0; N 0 0 1&quot;, basis=&quot;ccpvdz&quot;)
mf = scf.RHF(mol).run()
ncas = 6
nelec_cas = 6
mc = mcscf.CASCI(mf, ncas, nelec_cas)
mc.kernel()
mc = mcscf.CASSCF(mf, ncas, nelec_cas)
mc.kernel()
</pre></div>
</div>
<p>The Python script <code class="file docutils literal notranslate"><span class="pre">c2_cas.py</span></code> can be executed by Python interpreter in
command line:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ python c2_cas.py
converged SCF energy = -108.929838385609
CASCI E = -108.980200822148  E(CI) = -11.9360559617961  S^2 = 0.0000000
CASSCF energy = -109.044401900068
</pre></div>
</div>
<p>Based on the given active space size and number of correlated electrons, the
CASCI/CASSCF solver by default takes the highest occupied and lowest unoccupied
orbitals to form the active space.  To change the active space, you need prepare
a set of orbitals and reorder the orbitals to place the required active orbitals
in the HOMO and LUMO space.  You can feed the reordered orbitals to function
<code class="docutils literal notranslate"><span class="pre">mc.kernel(orbs)</span></code> as the initial guess.  CASCI/CASSCF solver will take the
“HOMO/LUMO” orbitals from <code class="docutils literal notranslate"><span class="pre">orbs</span></code> as the active space.  It is inconvenient to
prepare the active space through this selecting-then-reordering procedure.
To simplify this procedure, PySCF package provides some helper functions, such
as <code class="xref py py-meth docutils literal notranslate"><span class="pre">sort_mo()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">sort_mo_by_irrep()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">dmet_cas.guess_cas()</span></code>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">atomic_valence()</span></code> <a class="footnote-reference brackets" href="#id3" id="id1">1</a>.
In the following example, we selected 4 <span class="math notranslate nohighlight">\(\pi\)</span> orbitals and 1 <span class="math notranslate nohighlight">\(\sigma\)</span>
orbital and 1 <span class="math notranslate nohighlight">\(\sigma^*\)</span> orbital from mean-field molecular orbitals to
form the active space using the helper function <code class="xref py py-meth docutils literal notranslate"><span class="pre">sort_mo_by_irrep()</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span> <span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="linenos">2</span> <span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s2">&quot;N 0 0 0; N 0 0 1&quot;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s2">&quot;ccpvdz&quot;</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="linenos">3</span> <span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="linenos">4</span>
<span class="linenos">5</span> <span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="linenos">6</span> <span class="n">ncas_by_irreps</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;E1ux&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;E1uy&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;A1g&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;A1u&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span>
<span class="linenos">7</span> <span class="n">orbs</span> <span class="o">=</span> <span class="n">mc</span><span class="o">.</span><span class="n">sort_mo_by_irrep</span><span class="p">(</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">ncas_by_irreps</span><span class="p">)</span>
<span class="linenos">8</span> <span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">orbs</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above example, you should read the input as a Python program.  Line 2
creates a molecule and applied mean-field calculation on the molecule.  The
mean-field results are saved in <code class="docutils literal notranslate"><span class="pre">mf</span></code> object so that you can access them later.
For example, in line 5, HF MOs <code class="docutils literal notranslate"><span class="pre">mf.mo_coeff</span></code> are passed to function
<code class="xref py py-meth docutils literal notranslate"><span class="pre">mc.sort_mo_by_irrep()</span></code>.  <code class="xref py py-meth docutils literal notranslate"><span class="pre">mc.sort_mo_by_irrep()</span></code> read the configs from
<code class="docutils literal notranslate"><span class="pre">ncas_by_irreps</span></code> and return the reordered orbitals <code class="docutils literal notranslate"><span class="pre">orbs</span></code> which is then fed
to <code class="xref py py-meth docutils literal notranslate"><span class="pre">mc.kernel()</span></code> function as the initial guess.  <code class="docutils literal notranslate"><span class="pre">mc</span></code> is the CASSCF object
created by <code class="docutils literal notranslate"><span class="pre">mcscf.CASSCF</span></code> function.  More options can be specified for <code class="docutils literal notranslate"><span class="pre">mc</span></code>
object to control the calculation.  For example, you can set the convergence
tolerance <code class="docutils literal notranslate"><span class="pre">mc.conv_tol</span> <span class="pre">=</span> <span class="pre">1e-6</span></code>; require more computation details to be printed
in the output with <code class="docutils literal notranslate"><span class="pre">mc.verbose=5</span></code>; call <code class="xref py py-func docutils literal notranslate"><span class="pre">mc.analyze()</span></code> to print out the
population analysis of the CASCI/CASSCF results.  The FCI solver of CASCI/CASSCF
object is handled by the attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">mc.fcisolver</span></code>.  You can control the
number of roots to compute by setting <code class="docutils literal notranslate"><span class="pre">mc.fcisolver.nroots</span> <span class="pre">=</span> <span class="pre">3</span></code>, or change the
symmetry of the correlated wave function with <code class="docutils literal notranslate"><span class="pre">mc.fcisolver.wfnsym</span> <span class="pre">=</span> <span class="pre">'A1u'</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s2">&quot;N 0 0 0; N 0 0 1&quot;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s2">&quot;ccpvdz&quot;</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASCI</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">ncas_by_irreps</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;E1ux&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;E1uy&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;A1g&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;A1u&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span>
<span class="n">orbs</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">sort_mo_by_irrep</span><span class="p">(</span><span class="n">mc</span><span class="p">,</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">ncas_by_irreps</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">nroots</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">wfnsym</span> <span class="o">=</span> <span class="s1">&#39;a1u&#39;</span>
<span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">orbs</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">analyze</span><span class="p">()</span>
</pre></div>
</div>
<p>Replacing <code class="xref py py-attr docutils literal notranslate"><span class="pre">mc.fcisolver</span></code> with DMRG solver leads to the DMRG-CASCI and
DMRG-CASSCF methods.  But the rest of the input code should be the same to the
regular CASCI/CASSCF calculation.  You need the molecule and the mean-field
objects to create the DMRG-CASCI/DMRG-CASSCF object <code class="docutils literal notranslate"><span class="pre">mc</span></code>.  You can adjust the
parameters in <code class="docutils literal notranslate"><span class="pre">mc</span></code> object to control the DMRG-CASCI/DMRG-CASSCF calculation
and adjust DMRG configs through the <code class="xref py py-attr docutils literal notranslate"><span class="pre">mc.fcisolver</span></code> object.
More CASCI/CASSCF parameters are documented in <a class="reference external" href="http://www.pyscf.org/mcscf.html">http://www.pyscf.org/mcscf.html</a></p>
</div>
<div class="section" id="setup-block-in-pyscf-package">
<h2>Setup Block in PySCF package<a class="headerlink" href="#setup-block-in-pyscf-package" title="Permalink to this headline">¶</a></h2>
<p>First is to <a class="reference internal" href="build.html#build"><span class="std std-ref">prepare the Block executable binary</span></a>.
Next, you need setup the Block runtime environment in PySCF.  In the config file
<code class="file docutils literal notranslate"><span class="pre">/path/to/pyscf/future/dmrgscf/settings.py</span></code> (see also the template
<code class="file docutils literal notranslate"><span class="pre">/path/to/pyscf/future/dmrgscf/settings.py.template</span></code>), you need specify:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BLOCKEXE</span> <span class="o">=</span> <span class="s2">&quot;/path/to/Block/block.spin_adapted&quot;</span>
<span class="n">BLOCKEXE_COMPRESS_NEVPT</span> <span class="o">=</span> <span class="s2">&quot;/path/to/serially/compiled/Block/block.spin_adapted&quot;</span>
<span class="n">BLOCKSCRATCHDIR</span> <span class="o">=</span> <span class="s2">&quot;/path/to/scratch&quot;</span>
<span class="n">MPIPREFIX</span> <span class="o">=</span> <span class="s2">&quot;mpirun&quot;</span>  <span class="c1"># or srun for SLURM system</span>
</pre></div>
</div>
<p>You need at least set <code class="docutils literal notranslate"><span class="pre">BLOCKEXE</span></code> for DMRG-CASCI and DMRG-CASSCF methods.
<code class="docutils literal notranslate"><span class="pre">BLOCKSCRATCHDIR</span></code> is the directory where to store temporary data and the DMRG
wave function.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Usually, the size of DMRG wave function is very large.  Be sure that the disk
which <code class="docutils literal notranslate"><span class="pre">BLOCKSCRATCHDIR</span></code> pointed to has enough space.</p>
</div>
<p>In the input script, you can replace the <code class="xref py py-attr docutils literal notranslate"><span class="pre">mc.fcisolver</span></code> by
<a class="reference external" href="http://www.pyscf.org/dmrgscf.html#id1">DMRGCI</a> object to call Block program
in CASCI/CASSCF calculation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">dmrgscf</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s2">&quot;N 0 0 0; N 0 0 1&quot;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s2">&quot;ccpvdz&quot;</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASCI</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">ncas_by_irreps</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;E1ux&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;E1uy&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;A1g&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;A1u&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span>
<span class="n">orbs</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">sort_mo_by_irrep</span><span class="p">(</span><span class="n">mc</span><span class="p">,</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">ncas_by_irreps</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">dmrgscf</span><span class="o">.</span><span class="n">DMRGCI</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">nroots</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">wfnsym</span> <span class="o">=</span> <span class="s1">&#39;a1u&#39;</span>
<span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">orbs</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">analyze</span><span class="p">()</span>
</pre></div>
</div>
<p>Generally speaking, this simple replacement of <code class="xref py py-attr docutils literal notranslate"><span class="pre">mc.fcisolver</span></code> is enough to
call the DMRG-CASCI and DMRG-CASSCF methods in your calculation.  The rest
settings of the <code class="docutils literal notranslate"><span class="pre">mc</span></code> object are all the same to the regular CASCI/CASSCF.
When <code class="xref py py-func docutils literal notranslate"><span class="pre">mc.kernel()</span></code> is finished, the CASCI/CASSCF results such as orbital
coefficients, natural occupancy etc. are held in <code class="docutils literal notranslate"><span class="pre">mc</span></code> object.  But the DMRG
wave-function is not.  It is stored in the directory specified by the attribute
<code class="docutils literal notranslate"><span class="pre">DMRGCI.scratchDirectory</span></code> or <code class="docutils literal notranslate"><span class="pre">BLOCKSCRATCHDIR</span></code> (the default value) in
the config <code class="file docutils literal notranslate"><span class="pre">pyscf/future/dmrgscf/settings.py</span></code>.</p>
<p>To make the embedded DMRG solver work more efficiently in CASSCF optimization,
one needs carefully tune the DMRG parameters and dynamically update the
parameters during the CASSCF optimization.  It requires more codes in the
interface to let CASSCF and DMRG talk to each other.  We provided a shortcut
function <a class="reference internal" href="#DMRGSCF" title="DMRGSCF"><code class="xref py py-func docutils literal notranslate"><span class="pre">DMRGSCF()</span></code></a> in the <code class="xref py py-mod docutils literal notranslate"><span class="pre">dmrgscf</span></code> module to handle this
functionality:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">dmrgscf</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s2">&quot;N 0 0 0; N 0 0 1&quot;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s2">&quot;ccpvdz&quot;</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="n">mc</span> <span class="o">=</span> <span class="n">dmrgscf</span><span class="o">.</span><span class="n">DMRGSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">ncas_by_irreps</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;E1ux&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;E1uy&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;A1g&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;A1u&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span>
<span class="n">orbs</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">sort_mo_by_irrep</span><span class="p">(</span><span class="n">mc</span><span class="p">,</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">ncas_by_irreps</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">wfnsym</span> <span class="o">=</span> <span class="s1">&#39;a1u&#39;</span>
<span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">orbs</span><span class="p">)</span>
</pre></div>
</div>
<p>We recommend to use <code class="xref py py-func docutils literal notranslate"><span class="pre">dmrgscf.DMRGSCF()</span></code> as the entry of DMRG-CASSCF method
whenever is possible.</p>
</div>
<div class="section" id="control-block-program-through-pyscf-wrapper">
<h2>Control Block program through PySCF wrapper<a class="headerlink" href="#control-block-program-through-pyscf-wrapper" title="Permalink to this headline">¶</a></h2>
<div class="section" id="parallelism">
<h3>Parallelism<a class="headerlink" href="#parallelism" title="Permalink to this headline">¶</a></h3>
<p>MPI parallelization parameters for Block are controlled by the variable
<code class="docutils literal notranslate"><span class="pre">MPIPREFIX</span></code> in <code class="file docutils literal notranslate"><span class="pre">pyscf/future/dmrgscf/settings.py</span></code> or the attribute
<code class="xref py py-attr docutils literal notranslate"><span class="pre">mpiprefix</span></code> of <a class="reference internal" href="#DMRGCI" title="DMRGCI"><code class="xref py py-class docutils literal notranslate"><span class="pre">DMRGCI</span></code></a> object.  For example, if you want to run
Block using 4 processors on 2 nodes with Infiniband as the communication layer,
you can specify in the input script:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mc</span> <span class="o">=</span> <span class="n">dmrgscf</span><span class="o">.</span><span class="n">DMRGSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">mpiprefix</span> <span class="o">=</span> <span class="s1">&#39;mpirun -np 4 -npernode --mca btl self,openib&#39;</span>
<span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
<p>If you are using <a class="reference external" href="https://www.open-mpi.org/faq/?category=slurm">SLURM</a> system
for job manager,  you can put <code class="docutils literal notranslate"><span class="pre">MPIPREFIX</span> <span class="pre">=</span> <span class="pre">'srun'</span></code> in the <code class="file docutils literal notranslate"><span class="pre">settings.py</span></code></p>
<p>To efficiently use memory, starting from Block-1.5, Block code introduces
threading level parallelism, more specifically, the OpenMP threading.  To enable
the multi-threading feature in Block, you need specify the attribute
<code class="xref py py-attr docutils literal notranslate"><span class="pre">num_thrds</span></code> in <a class="reference internal" href="#DMRGCI" title="DMRGCI"><code class="xref py py-class docutils literal notranslate"><span class="pre">DMRGCI</span></code></a> object to indicate the maximum number of
threads to be used by each MPI process:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mc</span> <span class="o">=</span> <span class="n">dmrgscf</span><span class="o">.</span><span class="n">DMRGSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">num_thrds</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
<p>By default, Block code uses 1 thread in each process.  Using the multi-threading
with the multi-processing model (mpirun -np) potentially offers higher
performance and better scaling for DMRG parallelism.  It is recommended to
enable the multi-threading feature if your block program is newer than version
1.5.</p>
<p>On SLURM job system, the hybrid parallelism settings are controlled by
<a class="reference external" href="http://slurm.schedmd.com/sbatch.html#lbAG">SLURM runtime environment variables</a>.
You can control the parallel model by either configuring the resources through
the <code class="docutils literal notranslate"><span class="pre">#SBATCH</span></code> flags or setting the <code class="docutils literal notranslate"><span class="pre">$SLURM_XXX</span></code> variables in the SLURM
script.  For example, the following slurm script allocated in total 32 CPUs
which are distributed in 8 processes on 2 nodes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#SBATCH --nodes=2</span>
<span class="c1">#SBATCH --ntasks-per-node=4</span>
<span class="c1">#SBATCH --cpus-per-task=4</span>

<span class="n">python</span> <span class="n">c2_cas</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>Specifying <code class="docutils literal notranslate"><span class="pre">mc.fcisolver.mpiprefix</span> <span class="pre">=</span> <span class="pre">'srun'</span></code> will use SLURM to lanuch the
Block program which will be executed on 2 nodes with 4 processes on each node.
Note Block program does not detect the environment and setup the multi-threading
automatically.  You still need explicitly set <code class="docutils literal notranslate"><span class="pre">mc.fcisolver.num_thrds</span> <span class="pre">=</span> <span class="pre">4</span></code> in
the PySCF input script to turn on the multi-threading for Block program.</p>
</div>
<div class="section" id="bond-dimension-and-sweep-scheduler">
<h3>Bond dimension and sweep scheduler<a class="headerlink" href="#bond-dimension-and-sweep-scheduler" title="Permalink to this headline">¶</a></h3>
<p>Depending on the system, you may need change the DMRG bond dimension to improve
the accuracy or balance the accuracy and efficiency.  The default bond dimension
is 1000.  You can change the bond dimension by setting <code class="xref py py-attr docutils literal notranslate"><span class="pre">fcisolver.maxM</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">dmrgscf</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s2">&quot;N 0 0 0; N 0 0 1&quot;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s2">&quot;ccpvdz&quot;</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="n">mc</span> <span class="o">=</span> <span class="n">dmrgscf</span><span class="o">.</span><span class="n">DMRGSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">maxM</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
<p>Generally, other default scheduler implemented in the PySCF wrapper should work
fine in most systems.  You can adjust the sweep schedule through the
<a class="reference internal" href="#DMRGCI" title="DMRGCI"><code class="xref py py-class docutils literal notranslate"><span class="pre">DMRGCI</span></code></a> object:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dmrgsolver</span><span class="o">.</span><span class="n">scheduleSweeps</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">30</span><span class="p">]</span>
<span class="n">dmrgsolver</span><span class="o">.</span><span class="n">scheduleMaxMs</span>  <span class="o">=</span> <span class="p">[</span><span class="mi">200</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="mi">800</span><span class="p">,</span> <span class="mi">1200</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">2000</span><span class="p">]</span>
<span class="n">dmrgsolver</span><span class="o">.</span><span class="n">scheduleTols</span>   <span class="o">=</span> <span class="p">[</span><span class="mf">0.0001</span><span class="p">,</span> <span class="mf">0.0001</span><span class="p">,</span> <span class="mf">0.0001</span><span class="p">,</span> <span class="mf">0.0001</span><span class="p">,</span> <span class="mf">1e-5</span><span class="p">,</span> <span class="mf">1e-7</span><span class="p">,</span> <span class="mf">1e-7</span><span class="p">,</span> <span class="mf">1e-7</span><span class="p">]</span>
<span class="n">dmrgsolver</span><span class="o">.</span><span class="n">scheduleNoises</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0001</span><span class="p">,</span> <span class="mf">0.0001</span><span class="p">,</span> <span class="mf">0.0001</span><span class="p">,</span> <span class="mf">0.0001</span><span class="p">,</span> <span class="mf">0.0001</span><span class="p">,</span> <span class="mf">0.0001</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>
<span class="n">dmrgsolver</span><span class="o">.</span><span class="n">twodot_to_onedot</span> <span class="o">=</span> <span class="mi">34</span>
<span class="n">dmrgsolver</span><span class="o">.</span><span class="n">maxIter</span> <span class="o">=</span> <span class="mi">50</span>
</pre></div>
</div>
<p>The first four attributes which prefixed with <code class="docutils literal notranslate"><span class="pre">schedule</span></code> will be converted to
the <code class="docutils literal notranslate"><span class="pre">schedule</span></code> section in the Block config file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">schedule</span>
  <span class="mi">0</span>  <span class="mi">200</span>   <span class="mf">0.0001</span>  <span class="mf">0.0001</span>
  <span class="mi">4</span>  <span class="mi">400</span>   <span class="mf">0.0001</span>  <span class="mf">0.0001</span>
  <span class="mi">8</span>  <span class="mi">800</span>   <span class="mf">0.0001</span>  <span class="mf">0.0001</span>
  <span class="mi">12</span> <span class="mi">1200</span>  <span class="mf">0.0001</span>  <span class="mf">0.0001</span>
  <span class="mi">16</span> <span class="mi">2000</span>  <span class="mf">1e-5</span>    <span class="mf">0.0001</span>
  <span class="mi">20</span> <span class="mi">2000</span>  <span class="mf">1e-7</span>    <span class="mf">0.0001</span>
  <span class="mi">24</span> <span class="mi">2000</span>  <span class="mf">1e-7</span>    <span class="mf">0.0</span>
  <span class="mi">30</span> <span class="mi">2000</span>  <span class="mf">1e-7</span>    <span class="mf">0.0</span>
<span class="n">end</span>
</pre></div>
</div>
<p>In the early stage of Block sweep, the wave function is easy to stuck at local
minimum.  Although less efficient and accurate, applying the two-dot algorithm
can effectively help DMRG solver moving out of the local minimum.  Attribute
<code class="xref py py-attr docutils literal notranslate"><span class="pre">twodot_to_onedot</span></code> indicates when to switch to the one-dot algorithm which
is efficient and stable to converge.</p>
</div>
<div class="section" id="dmrgci-functions-and-attributes">
<h3>DMRGCI functions and attributes<a class="headerlink" href="#dmrgci-functions-and-attributes" title="Permalink to this headline">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="DMRGCI">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">DMRGCI</span></span><a class="headerlink" href="#DMRGCI" title="Permalink to this definition">¶</a></dt>
<dd><p>The interface of Block and PySCF.  The class exposes the Block keywords to
PySCF so that the Block code can be run and controlled in Python script.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="DMRGCI.approx_maxIter">
<span class="sig-name descname"><span class="pre">approx_maxIter</span></span><a class="headerlink" href="#DMRGCI.approx_maxIter" title="Permalink to this definition">¶</a></dt>
<dd><p>In 1-step DMRG-CASSCF algorithm, the number of sweeps during the approximate
FCI/DMRG updating.  Default is 4</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="DMRGCI.block_extra_keyword">
<span class="sig-name descname"><span class="pre">block_extra_keyword</span></span><a class="headerlink" href="#DMRGCI.block_extra_keyword" title="Permalink to this definition">¶</a></dt>
<dd><p>It allows you to input Block keywords which were not exposed in <a class="reference internal" href="#DMRGCI" title="DMRGCI"><code class="xref py py-class docutils literal notranslate"><span class="pre">DMRGCI</span></code></a>
class.  Some commonly used keywords include</p>
<blockquote>
<div><div class="line-block">
<div class="line">warmup local_2site</div>
<div class="line">nonspinadapted</div>
<div class="line">fiedler</div>
</div>
</div></blockquote>
<p>See <a class="reference internal" href="keywords.html#keywords-list"><span class="std std-ref">Keywords</span></a> for the details of Block code keywords</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="DMRGCI.configFile">
<span class="sig-name descname"><span class="pre">configFile</span></span><a class="headerlink" href="#DMRGCI.configFile" title="Permalink to this definition">¶</a></dt>
<dd><p>By default, keywords are written to file dmrg.conf</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="DMRGCI.dmrg_switch_tol">
<span class="sig-name descname"><span class="pre">dmrg_switch_tol</span></span><a class="headerlink" href="#DMRGCI.dmrg_switch_tol" title="Permalink to this definition">¶</a></dt>
<dd><p>In 1-step DMRG-CASSCF, when the orbital gradients is smaller than this
value, the DMRG calculation starts to read the solution from previous step
as the initial guess (to reduce the computational cost).  Default is 1e-3.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="DMRGCI.executable">
<span class="sig-name descname"><span class="pre">executable</span></span><a class="headerlink" href="#DMRGCI.executable" title="Permalink to this definition">¶</a></dt>
<dd><p>Default is settings.BLOCKEXE</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="DMRGCI.integralFile">
<span class="sig-name descname"><span class="pre">integralFile</span></span><a class="headerlink" href="#DMRGCI.integralFile" title="Permalink to this definition">¶</a></dt>
<dd><p>The file to store FCIDUMP.  Default is FCIDUMP</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="DMRGCI.maxIter">
<span class="sig-name descname"><span class="pre">maxIter</span></span><a class="headerlink" href="#DMRGCI.maxIter" title="Permalink to this definition">¶</a></dt>
<dd><p>Max number of sweeps</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="DMRGCI.memory">
<span class="sig-name descname"><span class="pre">memory</span></span><a class="headerlink" href="#DMRGCI.memory" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximum memory (in GB) to use.  Default is 2 GB.  When you enabled multi
threading and had large bond dimensions <code class="xref py py-attr docutils literal notranslate"><span class="pre">maxM</span></code>, you might need
more memory to hold the intermediates.  Generally, large memory is helpful
to improve efficiency.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version Block-1.5: </span>(stackblock)</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="DMRGCI.mpiprefix">
<span class="sig-name descname"><span class="pre">mpiprefix</span></span><a class="headerlink" href="#DMRGCI.mpiprefix" title="Permalink to this definition">¶</a></dt>
<dd><p>Default is settings.MPIPREFIX</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="DMRGCI.nroots">
<span class="sig-name descname"><span class="pre">nroots</span></span><a class="headerlink" href="#DMRGCI.nroots" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of states to solver simultaneously.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="DMRGCI.num_thrds">
<span class="sig-name descname"><span class="pre">num_thrds</span></span><a class="headerlink" href="#DMRGCI.num_thrds" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of OpenMP threads to be used in each MPI process.  Default is 1.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="DMRGCI.outputFile">
<span class="sig-name descname"><span class="pre">outputFile</span></span><a class="headerlink" href="#DMRGCI.outputFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Block output.  Default is dmrg.out</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="DMRGCI.outputlevel">
<span class="sig-name descname"><span class="pre">outputlevel</span></span><a class="headerlink" href="#DMRGCI.outputlevel" title="Permalink to this definition">¶</a></dt>
<dd><p>0 (less output) to 3 (very noise).  Default is 2.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="DMRGCI.restart">
<span class="sig-name descname"><span class="pre">restart</span></span><a class="headerlink" href="#DMRGCI.restart" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether to read the wave function from the temporary directory (specified by
<a class="reference internal" href="#DMRGCI.scratchDirectory" title="DMRGCI.scratchDirectory"><code class="xref py py-attr docutils literal notranslate"><span class="pre">scratchDirectory</span></code></a>) as the initial guess.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Block code does not check whether the system of the existed wave funciton
matches the one in study.  A mismatched DMRG wave function (from wrong
<a class="reference internal" href="#DMRGCI.scratchDirectory" title="DMRGCI.scratchDirectory"><code class="xref py py-attr docutils literal notranslate"><span class="pre">DMRGCI.scratchDirectory</span></code></a>) may lead to wrong solution or cause
DMRG program crash.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="DMRGCI.runtimeDir">
<span class="sig-name descname"><span class="pre">runtimeDir</span></span><a class="headerlink" href="#DMRGCI.runtimeDir" title="Permalink to this definition">¶</a></dt>
<dd><p>Where to put files dmrg.conf, dmrg.out etc temporarily.  Default is current
directory (where you execute python).</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="DMRGCI.scratchDirectory">
<span class="sig-name descname"><span class="pre">scratchDirectory</span></span><a class="headerlink" href="#DMRGCI.scratchDirectory" title="Permalink to this definition">¶</a></dt>
<dd><p>The directory where to store the intermediates and wave functions.  Default
is settings.BLOCKSCRATCHDIR.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Be sure <code class="docutils literal notranslate"><span class="pre">mc.fcisolver.scratchDirectory</span></code> is properly assigned.
Since all DMRGCI object by default uses the same <code class="docutils literal notranslate"><span class="pre">BLOCKSCRATCHDIR</span></code> settings,
it’s easy to cause name conflicts on the scratch directory, especially when
two DMRG-CASSCF calculations are run on the same node.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="DMRGCI.spin">
<span class="sig-name descname"><span class="pre">spin</span></span><a class="headerlink" href="#DMRGCI.spin" title="Permalink to this definition">¶</a></dt>
<dd><p>2S (= nelec_alpha - nelec_beta).  If the argument <code class="docutils literal notranslate"><span class="pre">nelec</span></code> of
<a class="reference internal" href="#DMRGCI.kernel" title="DMRGCI.kernel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DMRGCI.kernel()</span></code></a> function is a two-item list to represent the number of
alpha and beta electrons, the Block program will use the given alpha and
beta electron numbers to determine the spin.  Otherwise, Block program
takes this value as the spin of the system.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="DMRGCI.twodot_to_onedot">
<span class="sig-name descname"><span class="pre">twodot_to_onedot</span></span><a class="headerlink" href="#DMRGCI.twodot_to_onedot" title="Permalink to this definition">¶</a></dt>
<dd><p>When to switch to one-dot algorithm.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="DMRGCI.weights">
<span class="sig-name descname"><span class="pre">weights</span></span><a class="headerlink" href="#DMRGCI.weights" title="Permalink to this definition">¶</a></dt>
<dd><p>In state average calculation, the weight assocated to each state.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="DMRGCI.wfnsym">
<span class="sig-name descname"><span class="pre">wfnsym</span></span><a class="headerlink" href="#DMRGCI.wfnsym" title="Permalink to this definition">¶</a></dt>
<dd><p>In the DMRGCI interface, the wave function symmetry ID follows the PySCF
convention (see <a class="reference external" href="http://www.pyscf.org/symm.html">http://www.pyscf.org/symm.html</a>).  But Block code follows
Molpro convention.  A mapping between two symmetry ID is invoked in the
DMRGCI initialization function.  It is recommended to put the label of wave
function  (such as ‘A1g’, ‘B2u’) here to avoid the ambiguity.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="DMRGCI.make_rdm1">
<span class="sig-name descname"><span class="pre">make_rdm1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#DMRGCI.make_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Given state ID, read its 1-particle density matrix from the directory
indicated by <a class="reference internal" href="#DMRGCI.scratchDirectory" title="DMRGCI.scratchDirectory"><code class="xref py py-attr docutils literal notranslate"><span class="pre">scratchDirectory</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="DMRGCI.make_rdm12">
<span class="sig-name descname"><span class="pre">make_rdm12</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#DMRGCI.make_rdm12" title="Permalink to this definition">¶</a></dt>
<dd><p>Given state ID, read its 1-particle and 2-particle density matrices from the
directory indicated by <a class="reference internal" href="#DMRGCI.scratchDirectory" title="DMRGCI.scratchDirectory"><code class="xref py py-attr docutils literal notranslate"><span class="pre">scratchDirectory</span></code></a>.  Note the 2-particle
density matrix is reordered to match the 2e integrals of chemists’ notation,
dm2[p,q,r,s] <span class="math notranslate nohighlight">\(= \langle p^\dagger r^\dagger s q\rangle\)</span>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="DMRGCI.make_rdm123">
<span class="sig-name descname"><span class="pre">make_rdm123</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#DMRGCI.make_rdm123" title="Permalink to this definition">¶</a></dt>
<dd><p>Given state ID, read 1, 2 and 3-particle density matrices from the
directory indicated by <a class="reference internal" href="#DMRGCI.scratchDirectory" title="DMRGCI.scratchDirectory"><code class="xref py py-attr docutils literal notranslate"><span class="pre">scratchDirectory</span></code></a>.  Note the 2-particle
density matrix is reordered to match the 2e integrals of chemists’ notation.
dm2[p,q,r,s] = <span class="math notranslate nohighlight">\(\langle p^\dagger r^\dagger s q\rangle\)</span>;  The
3-particle density matrix takes the similar convention,
dm3[p,q,r,s,t,u] <span class="math notranslate nohighlight">\(= \langle p^\dagger r^\dagger t^\dagger u s q\rangle\)</span>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="DMRGCI.trans_rdm1">
<span class="sig-name descname"><span class="pre">trans_rdm1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">statebra</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateket</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#DMRGCI.trans_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the state ID of bra and ket, read the 1-particle density matrix from
the directory indicated by <a class="reference internal" href="#DMRGCI.scratchDirectory" title="DMRGCI.scratchDirectory"><code class="xref py py-attr docutils literal notranslate"><span class="pre">scratchDirectory</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="DMRGCI.trans_rdm12">
<span class="sig-name descname"><span class="pre">trans_rdm12</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">statebra</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateket</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#DMRGCI.trans_rdm12" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the state ID of bra and ket, read the 1-particle and 2-particle
density matrices from the directory indicated by <a class="reference internal" href="#DMRGCI.scratchDirectory" title="DMRGCI.scratchDirectory"><code class="xref py py-attr docutils literal notranslate"><span class="pre">scratchDirectory</span></code></a>.
Note the 2-particle density matrix is reordered to match the 2e integrals of
chemists’ notation, dm2[p,q,r,s] <span class="math notranslate nohighlight">\(= \langle p^\dagger r^\dagger s q\rangle\)</span>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="DMRGCI.kernel">
<span class="sig-name descname"><span class="pre">kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">h1e</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eri</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fciRestart</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ecore</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#DMRGCI.kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>The kernel function to call Block program.  “eri” is the array of 2-electron
integrals (ij|kl).  8-fold permutation symmetry is required.
The function returns the total energy and the state ID which is
corresponding to the wave-function files in <a class="reference internal" href="#DMRGCI.scratchDirectory" title="DMRGCI.scratchDirectory"><code class="xref py py-attr docutils literal notranslate"><span class="pre">scratchDirectory</span></code></a>.
If multiple roots were required,  the function returns two lists.  The first
list is the energy of each state.  The second is a list of state ID.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="DMRGSCF">
<span class="sig-name descname"><span class="pre">DMRGSCF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#DMRGSCF" title="Permalink to this definition">¶</a></dt>
<dd><p>Shortcut function to setup CASSCF with the DMRG solver.  The DMRG
solver is properly initialized in this function so that the 1-step
algorithm can applied efficiently in DMRG-CASSCF method.</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">DMRGSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="go">-74.414908818611522</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="state-average-and-state-specific-dmrg-casci-dmrg-casscf">
<h2>State-average and state-specific DMRG-CASCI/DMRG-CASSCF<a class="headerlink" href="#state-average-and-state-specific-dmrg-casci-dmrg-casscf" title="Permalink to this headline">¶</a></h2>
<p>State-average and state-specific calculations were also supported in the
DMRG-CASCI/DMRG-CASSCF through the Block-PySCF interface.  The usage is
the same to that in regular CASCI/CASSCF calculation.
<code class="xref py py-func docutils literal notranslate"><span class="pre">mc.state-average_()</span></code> function provides the average over the
multiple solutions over a single <code class="xref py py-attr docutils literal notranslate"><span class="pre">fcisolver</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mc</span> <span class="o">=</span> <span class="n">dmrgscf</span><span class="o">.</span><span class="n">DMRGSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="c1"># half-half average over ground state and first excited state</span>
<span class="n">mc</span><span class="o">.</span><span class="n">state_average_</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>
<span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
<p>In this example, <a class="reference internal" href="#DMRGSCF" title="DMRGSCF"><code class="xref py py-func docutils literal notranslate"><span class="pre">DMRGSCF()</span></code></a> replaced the <code class="xref py py-attr docutils literal notranslate"><span class="pre">fcisolver</span></code> with the
<a class="reference internal" href="#DMRGCI" title="DMRGCI"><code class="xref py py-class docutils literal notranslate"><span class="pre">DMRGCI</span></code></a> object.  Two DMRG states with the same spin and spatial
(point group) symmetry are computed and half-half averaged.  The two states are
saved on the disk indicated by <code class="xref py py-attr docutils literal notranslate"><span class="pre">mc.fcisolver.scratchDirectory</span></code>.
In many calculations, one would require the state-average for states with
different spin or spatial symmetry.  Multiple FCI/DMRG solvers need to be
created and each solver should handle one particular symmetry.  Function
<code class="xref py py-func docutils literal notranslate"><span class="pre">mcscf.state_average_mix_()</span></code> offers this functionality to mix different
solvers in a single <code class="xref py py-attr docutils literal notranslate"><span class="pre">fcisolver</span></code> object:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span><span class="p">,</span> <span class="n">dmrgscf</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s2">&quot;N 0 0 0; N 0 0 1&quot;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s2">&quot;ccpvdz&quot;</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="n">mc</span> <span class="o">=</span> <span class="n">dmrgscf</span><span class="o">.</span><span class="n">DMRGSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="o">.</span><span class="mi">25</span><span class="p">,</span> <span class="o">.</span><span class="mi">25</span><span class="p">]</span>
<span class="n">solver1</span> <span class="o">=</span> <span class="n">dmrgscf</span><span class="o">.</span><span class="n">DMRGCI</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="n">solver1</span><span class="o">.</span><span class="n">scratchDirectory</span> <span class="o">=</span> <span class="s1">&#39;/scratch/solver1&#39;</span>
<span class="n">solver1</span><span class="o">.</span><span class="n">nroots</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">solver1</span><span class="o">.</span><span class="n">wfnsym</span> <span class="o">=</span> <span class="s1">&#39;a1g&#39;</span>
<span class="n">solver1</span><span class="o">.</span><span class="n">spin</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># nelec_alpha - nelec_beta</span>
<span class="n">solver2</span> <span class="o">=</span> <span class="n">dmrgscf</span><span class="o">.</span><span class="n">DMRGCI</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="n">solver2</span><span class="o">.</span><span class="n">scratchDirectory</span> <span class="o">=</span> <span class="s1">&#39;/scratch/solver2&#39;</span>
<span class="n">solver2</span><span class="o">.</span><span class="n">nroots</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">solver2</span><span class="o">.</span><span class="n">wfnsym</span> <span class="o">=</span> <span class="s1">&#39;a1u&#39;</span>
<span class="n">mcscf</span><span class="o">.</span><span class="n">state_average_mix_</span><span class="p">(</span><span class="n">mc</span><span class="p">,</span> <span class="p">[</span><span class="n">solver1</span><span class="p">,</span> <span class="n">solver2</span><span class="p">],</span> <span class="n">weights</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
<p>In this example, one solver for a triplet state of A1g symmetry and another
solver for two singlet states of A1u symmetry are combined into one faked
solver and assigned to <code class="xref py py-attr docutils literal notranslate"><span class="pre">fcisolver</span></code> by <code class="xref py py-func docutils literal notranslate"><span class="pre">state_average_mix_()</span></code>.
If the fake solver needs to handle solvers of different spin symmetry, you
need explicitly assign the spin attribute to the solver.  For first solver
<code class="docutils literal notranslate"><span class="pre">solver1</span></code>, <code class="docutils literal notranslate"><span class="pre">solver1.spin</span> <span class="pre">=</span> <span class="pre">2</span></code> indciates that the number of
alpha electrons is 2 more than the number of beta electrons.
The <code class="xref py py-meth docutils literal notranslate"><span class="pre">kernel()</span></code> function of fake solver <code class="xref py py-attr docutils literal notranslate"><span class="pre">mc.fcisolver</span></code> will return 3
states in a list <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">0,</span> <span class="pre">1]</span></code>.  The number in the list represents the state
ID in each solver.  The first state (the first 0 in the list) is obtained from
<code class="docutils literal notranslate"><span class="pre">solver1</span></code>.  Its wave-function and density matrices can be found in
<code class="docutils literal notranslate"><span class="pre">/scratch/solver1</span></code>.  The second and third elements of <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">0,</span> <span class="pre">1]</span></code> are the
states obtained from <code class="docutils literal notranslate"><span class="pre">solver2</span></code>.  The relevant wave functions and density
matrices are all stored in <code class="docutils literal notranslate"><span class="pre">/scratch/solver2</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Block program stores the wave function in <code class="xref py py-attr docutils literal notranslate"><span class="pre">scratchDirectory</span></code>.
You must assign different <code class="xref py py-attr docutils literal notranslate"><span class="pre">scratchDirectory</span></code> for different DMRG solvers.
If two Block wave function are put in the same <code class="xref py py-attr docutils literal notranslate"><span class="pre">scratchDirectory</span></code>, the
solver may crash or produce wrong solution.</p>
</div>
<p>State-specific DMRG-CASSCF is the other common calculation one would take.
Setting up state-specific DMRG-CASSCF object is the same to the regular CASSCF
code.  By calling <code class="xref py py-meth docutils literal notranslate"><span class="pre">mc.state_specific_()</span></code> function with state ID: 0 for
ground state, 1 for first excited state …, you can optimize the target state
with DMRG-CASSCF:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Optimize the first excited state</span>
<span class="n">mc</span> <span class="o">=</span> <span class="n">dmrgscf</span><span class="o">.</span><span class="n">DMRGSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">state_specific_</span><span class="p">(</span><span class="n">state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">mc.state_specific_()</span></code> function can be applied with DMRG-CASCI object as
well.  However, a straightforward solution for DMRG-CASCI is to compute multiple
states simultaneously with attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">nroots</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASCI</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">dmrgscf</span><span class="o">.</span><span class="n">DMRGCI</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">nroots</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
<p>In PySCF <a class="reference external" href="https://github.com/pyscf/dmrgscf/tree/master/examples">source code</a>,
you can find more examples of state-average and state-specific calculations.</p>
</div>
<div class="section" id="dmrg-nevpt2">
<h2>DMRG-NEVPT2<a class="headerlink" href="#dmrg-nevpt2" title="Permalink to this headline">¶</a></h2>
<p>DMRG-NEVPT2 <a class="footnote-reference brackets" href="#id4" id="id2">2</a> calculations are available since Block-1.1.  In Block-1.1, we
implemented the standard DMRG-NEVPT2 method which requires the 4-particle
density matrix.  Computing and storing the 4-particle density matrix is
extremely demanding.  It limits the system size to at most 26 orbitals.
To handle systems with larger active space, we implemented an effective
approximation based on compressed MPS-perturber
technique which can significantly reduce the computation cost.  The MPS-perturber
NEVPT2 implementation requires the <a class="reference external" href="http://mpi4py.scipy.org">MPI4Py</a> library
and the <strong>serial version</strong> of Block program.  You need set in the config file
<code class="file docutils literal notranslate"><span class="pre">/path/to/pyscf/future/dmrgscf/settings.py</span></code> the variable
<code class="docutils literal notranslate"><span class="pre">BLOCKEXE_COMPRESS_NEVPT</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BLOCKEXE_COMPRESS_NEVPT</span> <span class="o">=</span> <span class="s2">&quot;/path/to/serially/compiled/Block/block.spin_adapted-serial&quot;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The wavefunction structure from different Block versions are incompatible.  If
BLOCKEXE for zeroth order wavefunction is set to Block-1.1, the variable
BLOCKEXE_COMPRESS_NEVPT should also be Block-1.1.  Similarly, Block-1.5
(stackblock) PT code only compatible with the zeroth order wavefunction of
Block-1.5 (stackblock).</p>
</div>
<p>Now you can use <code class="xref py py-func docutils literal notranslate"><span class="pre">compress_approx()</span></code> function to initialize a compressed
pertuber NEVPT2 method.  In the <code class="xref py py-func docutils literal notranslate"><span class="pre">compress_approx()</span></code> function, we precomputed
the most demanding intermediates and stored them on disk:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">dmrgscf</span><span class="p">,</span> <span class="n">mrpt</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s2">&quot;N 0 0 0; N 0 0 1&quot;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s2">&quot;ccpvdz&quot;</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">mc</span> <span class="o">=</span> <span class="n">dmrgscf</span><span class="o">.</span><span class="n">dmrgci</span><span class="o">.</span><span class="n">DMRGSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="n">mrpt</span><span class="o">.</span><span class="n">NEVPT</span><span class="p">(</span><span class="n">mc</span><span class="p">)</span><span class="o">.</span><span class="n">compress_approx</span><span class="p">()</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The compressed NEVPT2 algorithm is also very demanding, especially on the memory
usage.  It can support up to about 35 orbitals in Block-1.5.  Please refer to
the <a class="reference internal" href="benchmark.html#benchmark"><span class="std std-ref">Benchmark</span></a> for approximate costs.</p>
</div>
<p>If the excitation energy is of interest, we can use DMRG-NEVPT2 to compute the
energy of excited state based on the multiple-root CASCI calculations:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASCI</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">dmrgscf</span><span class="o">.</span><span class="n">DMRGCI</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">nroots</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="n">mrpt</span><span class="o">.</span><span class="n">NEVPT</span><span class="p">(</span><span class="n">mc</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">compress_approx</span><span class="p">(</span><span class="n">maxM</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">mrpt</span><span class="o">.</span><span class="n">NEVPT</span><span class="p">(</span><span class="n">mc</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">compress_approx</span><span class="p">(</span><span class="n">maxM</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>In the above example, two NEVPT2 calculations are called separately for
two states which are indicated by the argument <code class="docutils literal notranslate"><span class="pre">root=*</span></code>.  If the DMRG-NEVPT2
calculations are called based on the state-average DMRG-CASSCF calculation, you
should be very careful with <code class="xref py py-attr docutils literal notranslate"><span class="pre">scratchDirectory</span></code> for the DMRG wave function
that NEVPT2 perturbation is applied on.  In the multiple-solver state-average
DMRG-CASSCF calculation,  you need assign the right <code class="xref py py-attr docutils literal notranslate"><span class="pre">fcisolver</span></code> and state
ID to the <code class="docutils literal notranslate"><span class="pre">mc</span></code> object before passing it to <code class="xref py py-func docutils literal notranslate"><span class="pre">mrpt.NEVPT()</span></code> method.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mc</span> <span class="o">=</span> <span class="n">dmrgscf</span><span class="o">.</span><span class="n">DMRGSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="o">.</span><span class="mi">25</span><span class="p">,</span> <span class="o">.</span><span class="mi">25</span><span class="p">]</span>
<span class="n">solver1</span> <span class="o">=</span> <span class="n">dmrgscf</span><span class="o">.</span><span class="n">DMRGCI</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="n">solver1</span><span class="o">.</span><span class="n">scratchDirectory</span> <span class="o">=</span> <span class="s1">&#39;/scratch/solver1&#39;</span>
<span class="n">solver1</span><span class="o">.</span><span class="n">nroots</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">solver1</span><span class="o">.</span><span class="n">wfnsym</span> <span class="o">=</span> <span class="s1">&#39;a1g&#39;</span>
<span class="n">solver1</span><span class="o">.</span><span class="n">spin</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># nelec_alpha - nelec_beta</span>
<span class="n">solver2</span> <span class="o">=</span> <span class="n">dmrgscf</span><span class="o">.</span><span class="n">DMRGCI</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="n">solver2</span><span class="o">.</span><span class="n">scratchDirectory</span> <span class="o">=</span> <span class="s1">&#39;/scratch/solver2&#39;</span>
<span class="n">solver2</span><span class="o">.</span><span class="n">nroots</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">solver2</span><span class="o">.</span><span class="n">wfnsym</span> <span class="o">=</span> <span class="s1">&#39;a1u&#39;</span>
<span class="n">mcscf</span><span class="o">.</span><span class="n">state_average_mix_</span><span class="p">(</span><span class="n">mc</span><span class="p">,</span> <span class="p">[</span><span class="n">solver1</span><span class="p">,</span> <span class="n">solver2</span><span class="p">],</span> <span class="n">weights</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>

<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">solver1</span>
<span class="n">mrpt</span><span class="o">.</span><span class="n">NEVPT</span><span class="p">(</span><span class="n">mc</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">compress_approx</span><span class="p">(</span><span class="n">maxM</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">solver2</span>
<span class="n">mrpt</span><span class="o">.</span><span class="n">NEVPT</span><span class="p">(</span><span class="n">mc</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">compress_approx</span><span class="p">(</span><span class="n">maxM</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="case-study">
<h2>Case study<a class="headerlink" href="#case-study" title="Permalink to this headline">¶</a></h2>
<p>In this example, we computed the lowest excited states with DMRG-CASSCF and
DMRG-NEVPT2 methods.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="kn">from</span> <span class="nn">pyscf.mcscf</span> <span class="kn">import</span> <span class="n">avas</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">dmrgscf</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">mrpt</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">lib</span>

<span class="c1">#</span>
<span class="c1"># Adjust the MPI schedular and scratch directory if needed.</span>
<span class="c1">#</span>
<span class="c1">#from pyscf.dmrgscf import settings</span>
<span class="c1">#settings.MPIPREFIX = &#39;srun&#39;</span>
<span class="c1">#settings.BLOCKSCRATCHDIR = &#39;/scratch&#39;</span>


<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span>
    <span class="n">atom</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">V     0.000000    0.000000    0.000000</span>
<span class="s1">O     0.000000    0.000000    1.592000</span>
<span class="s1">Cl    1.639807    1.639807   -0.539657</span>
<span class="s1">Cl   -1.639807    1.639807   -0.539657</span>
<span class="s1">Cl    1.639807   -1.639807   -0.539657</span>
<span class="s1">Cl   -1.639807   -1.639807   -0.539657</span>
<span class="s1">&#39;&#39;&#39;</span><span class="p">,</span>
    <span class="n">basis</span> <span class="o">=</span> <span class="s1">&#39;cc-pvtz-dk&#39;</span><span class="p">,</span>
    <span class="n">spin</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">charge</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span>

<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">sfx2c1e</span><span class="p">(</span><span class="n">scf</span><span class="o">.</span><span class="n">ROHF</span><span class="p">(</span><span class="n">mol</span><span class="p">))</span>
<span class="n">mf</span><span class="o">.</span><span class="n">chkfile</span> <span class="o">=</span> <span class="s1">&#39;vocl4.chk&#39;</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>

<span class="c1">#</span>
<span class="c1"># Generate the DMRG-CASSCF initial guess with AVAS (atomic valence active space) method.</span>
<span class="c1">#</span>
<span class="n">norb_act</span><span class="p">,</span> <span class="n">ne_act</span><span class="p">,</span> <span class="n">mos</span> <span class="o">=</span> <span class="n">avas</span><span class="o">.</span><span class="n">avas</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;V 3s&#39;</span><span class="p">,</span> <span class="s1">&#39;V 3p&#39;</span><span class="p">,</span> <span class="s1">&#39;V 3d&#39;</span><span class="p">,</span> <span class="s1">&#39;O 2p&#39;</span><span class="p">,</span> <span class="s1">&#39;Cl 3p&#39;</span><span class="p">])</span>

<span class="c1">#</span>
<span class="c1"># Pass 1</span>
<span class="c1"># DMRG-CASSCF calculation with small M.  In many systems, the mcscf orbitals has</span>
<span class="c1"># weak dependence to the quality of the active space solution.  We can use small</span>
<span class="c1"># M to approximate the active space wave function and increase M for DMRG-CASCI</span>
<span class="c1"># and DMRG-NEVPT2 in next step.</span>
<span class="c1">#</span>
<span class="n">mc</span> <span class="o">=</span> <span class="n">dmrgscf</span><span class="o">.</span><span class="n">DMRGSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="n">norb_act</span><span class="p">,</span> <span class="n">ne_act</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">maxM</span> <span class="o">=</span> <span class="mi">500</span>
<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">extraline</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;num_thrds </span><span class="si">%d</span><span class="s1">&#39;</span><span class="o">%</span><span class="n">lib</span><span class="o">.</span><span class="n">num_threads</span><span class="p">(),</span> <span class="s1">&#39;warmup local_2site&#39;</span><span class="p">]</span>
<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">memory</span> <span class="o">=</span> <span class="mi">100</span>  <span class="c1"># GB</span>
<span class="n">mc</span><span class="o">.</span><span class="n">conv_tol</span> <span class="o">=</span> <span class="mf">1e-6</span>
<span class="n">mc</span><span class="o">.</span><span class="n">state_average_</span><span class="p">([</span><span class="o">.</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">mos</span><span class="p">)</span>
<span class="n">mc_orbs</span> <span class="o">=</span> <span class="n">mc</span><span class="o">.</span><span class="n">mo_coeff</span>


<span class="c1">#</span>
<span class="c1"># Pass 2</span>
<span class="c1"># A separated DMRG-CASCI calculation based on DMRG-CASSCF orbitals obtained and</span>
<span class="c1"># DMRG solver with large bond dimension to improve the multi configurational</span>
<span class="c1"># wave function.</span>
<span class="c1">#</span>
<span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASCI</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="n">norb_act</span><span class="p">,</span> <span class="n">ne_act</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">dmrgscf</span><span class="o">.</span><span class="n">DMRGCI</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">maxM</span> <span class="o">=</span> <span class="mi">1500</span>
<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">extraline</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;num_thrds </span><span class="si">%d</span><span class="s1">&#39;</span><span class="o">%</span><span class="n">lib</span><span class="o">.</span><span class="n">num_threads</span><span class="p">(),</span> <span class="s1">&#39;warmup local_2site&#39;</span><span class="p">]</span>
<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">memory</span> <span class="o">=</span> <span class="mi">100</span>  <span class="c1"># GB</span>
<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">nroots</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">mc_orbs</span><span class="p">)</span>


<span class="c1">#</span>
<span class="c1"># This step computes DMRG-NEVPT2 energy state-specificly. It is recommended to</span>
<span class="c1"># use large bond dimension (larger than the last DMRG-CASCI calculation) to</span>
<span class="c1"># guarantee the accuracy.</span>
<span class="c1">#</span>
<span class="nb">print</span> <span class="n">mrpt</span><span class="o">.</span><span class="n">NEVPT</span><span class="p">(</span><span class="n">mc</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">compress_approx</span><span class="p">(</span><span class="n">maxM</span><span class="o">=</span><span class="mi">2000</span><span class="p">)</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="nb">print</span> <span class="n">mrpt</span><span class="o">.</span><span class="n">NEVPT</span><span class="p">(</span><span class="n">mc</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">compress_approx</span><span class="p">(</span><span class="n">maxM</span><span class="o">=</span><span class="mi">2000</span><span class="p">)</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="nb">print</span> <span class="n">mrpt</span><span class="o">.</span><span class="n">NEVPT</span><span class="p">(</span><span class="n">mc</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">compress_approx</span><span class="p">(</span><span class="n">maxM</span><span class="o">=</span><span class="mi">2000</span><span class="p">)</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>

</pre></div>
</div>
</div>
<div class="section" id="run-block-standalone">
<h2>Run Block standalone<a class="headerlink" href="#run-block-standalone" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Block</span></code> program can be run standalone without the PySCF environment.
In PySCF-1.3,  the DMRG interface provides dry run mode to generate the Block
input config <code class="file docutils literal notranslate"><span class="pre">dmrg.conf</span></code> and the integral file
<code class="file docutils literal notranslate"><span class="pre">FCIDUMP</span></code>.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">dmrgscf</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s2">&quot;N 0 0 0; N 0 0 1&quot;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s2">&quot;ccpvdz&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">mc</span> <span class="o">=</span> <span class="n">dmrgscf</span><span class="o">.</span><span class="n">DMRGSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">dmrgscf</span><span class="o">.</span><span class="n">dryrun</span><span class="p">(</span><span class="n">mc</span><span class="p">)</span>
</pre></div>
</div>
<p>You can execute Block program in command line:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mpirun</span> <span class="o">-</span><span class="n">n</span> <span class="mi">2</span> <span class="n">block</span><span class="o">.</span><span class="n">spin_adapted</span> <span class="n">dmrg</span><span class="o">.</span><span class="n">conf</span> <span class="o">&gt;</span> <span class="n">dmrg</span><span class="o">.</span><span class="n">out</span>
</pre></div>
</div>
<p>See more examples in Chapter <a class="reference internal" href="examples.html#standalone"><span class="std std-ref">Block program as a standalone solver</span></a>.</p>
<p class="rubric">Footnotes</p>
<dl class="footnote brackets">
<dt class="label" id="id3"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><ol class="upperalpha simple" start="5">
<li><ol class="upperalpha simple" start="18">
<li><p>Sayfutyarova, Q. Sun, G. K.-L. Chan, G. Knizia, arXiv:1701.07862 [physics.chem-ph]</p></li>
</ol>
</li>
</ol>
</dd>
<dt class="label" id="id4"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><ol class="upperalpha simple" start="19">
<li><p>Guo, M. A. Watson, W. Hu, Q. Sun, G. K.-L. Chan, J. Chem.  Theory Comput. 12, 1583 (2016)</p></li>
</ol>
</dd>
</dl>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">DMRG for electronic structure calculations</a><ul>
<li><a class="reference internal" href="#casci-casscf-in-pyscf">CASCI/CASSCF in PySCF</a></li>
<li><a class="reference internal" href="#setup-block-in-pyscf-package">Setup Block in PySCF package</a></li>
<li><a class="reference internal" href="#control-block-program-through-pyscf-wrapper">Control Block program through PySCF wrapper</a><ul>
<li><a class="reference internal" href="#parallelism">Parallelism</a></li>
<li><a class="reference internal" href="#bond-dimension-and-sweep-scheduler">Bond dimension and sweep scheduler</a></li>
<li><a class="reference internal" href="#dmrgci-functions-and-attributes">DMRGCI functions and attributes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#state-average-and-state-specific-dmrg-casci-dmrg-casscf">State-average and state-specific DMRG-CASCI/DMRG-CASSCF</a></li>
<li><a class="reference internal" href="#dmrg-nevpt2">DMRG-NEVPT2</a></li>
<li><a class="reference internal" href="#case-study">Case study</a></li>
<li><a class="reference internal" href="#run-block-standalone">Run Block standalone</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="build.html"
                        title="previous chapter">Block Installation</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="examples.html"
                        title="next chapter">Block program as a standalone solver</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/with-pyscf.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="examples.html" title="Block program as a standalone solver"
             >next</a></li>
        <li class="right" >
          <a href="build.html" title="Block Installation"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">BLOCK 1.5.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">DMRG for electronic structure calculations</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2015, Garnet Kin-Lic Chan.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.1.1.
    </div>
  </body>
</html>